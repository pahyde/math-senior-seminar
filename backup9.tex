\documentclass[10pt]{wlscirep}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsthm}
\usepackage{listings}

\title{Review: "Build a Sporadic Group in Your Basement"}

\author[]{Parker Hyde}
\affil[]{Georgia State University, Mathematics and Statistics Department, Atlanta, 30302, U.S.A}
\affil[]{Email: phyde1@student.gsu.edu}

%\keywords{Keyword1, Keyword2, Keyword3}

\begin{abstract}
Example Abstract. Abstract must not include subheadings or citations. Example Abstract. Abstract must not include subheadings or citations. Example Abstract. Abstract must not include subheadings or citations. Example Abstract. Abstract must not include subheadings or citations. Example Abstract. Abstract must not include subheadings or citations. Example Abstract. Abstract must not include subheadings or citations. Example Abstract. Abstract must not include subheadings or citations.
\end{abstract}
\begin{document}

\flushbottom
\maketitle
% * <john.hammersley@gmail.com> 2015-02-09T12:07:31.197Z:
%
%  Click the title above to edit the author information and abstract
%
\thispagestyle{empty}

%\noindent Please note: Abbreviations should be introduced at the first mention in the main text – no abbreviations lists. Suggested structure of main text (not enforced) is provided below.

\section*{Introduction}


\paragraph{}

Any undergraduate student who has completed a course in abstract algebra will likely 
be familiar with the notion of a normal subgroup. 
A typical introductory textbook will introduce this 
concept early and 
%thoroughly 
emphasize its importance to fundamental 
ideas such as factor groups, cosets, and Lagrange's Theorem. 
%complementary 
%The relationship between normal groups and factor groups is often especially emphasized. 
%Readers of I.N. Hernstein's Topics in Algebra, for example, 
In particular, students will see a variety of examples in which a normal subgroup N of a groups G, yields a factor group \( G / N \) comprised of cosets from the original group G.
%In particular, a variety of examples in which a normal subgroup N of a groups G, yields a factor group \( G / N \) comprised of cosets from the original group G.
\paragraph{}

The group of residue classes modulo 5, denoted by \( Z_5 \), provides 
an %a particularly accessible 
example of this. The group can be obtained as a factor group, Z/5Z, from the group of integers 
Z with normal subgroup 5Z. 
The notation of this construction seems to suggest that \( Z \) can be decomosed
as a product of 'simpler' groups \( 5Z \) and \( Z_5 \). This feels analogous to 
the notion that composite numbers can be decomposed into a product of smaller numbers. 
But this analogy begs the question. When does a group act like a prime number in the
sense that it cannot be decomposed into simpler groups? %In pursuit of this question
%Reflecting on this example, we might recognize that 
%the group \( Z \) seems to permit a decomposition into a product of 
%'simpler' groups 5Z and Z5 in the way that composite numbers can be decomposed into a product 
%of smaller numbers. The student 
We might notice that Lagrange's Theorem forbids \( Z_5 \) from 
having a normal subgroup of its own due to its prime order. 
\( Z_5 \) seems to be an example of the prime number analogue we're looking for. 
This result leads to more questions than answers. Can we ascertain
which properties of  \( Z_5 \), such as it's cyclic nature or prime order, 
generalize to other 'simple' groups? Moreover, can we ever know if 
we've found all the groups with this property? For the case of "finite" simple groups,
groups of finite order which don't permit a normal subgroup, it turns out that 
we can. In fact, classifying
these groups is a monsterous problem which has been extensively researched over
the past century.
%This might suggest that Z5,  
%a cyclic group of order 5, is analogous to a prime number whose only factors are trivial. 
%Thus the student may reasonably conclude that Z5 is some kind of special simple group in the 
%sense that it is a finite group whose only proper normal subgroup is the trivial group. 
%Indeed, such groups are called "finite simple groups" and they are of incredible importance 
%in the modern landscape of group theory.

\paragraph{}
%Tremendous effort and volumes of mathematical literature have been exhausted in trying to 
%understand the so-called finite simple groups. 
It was only in recent decades that a large body of work, composed of 
over 10,000 pages written by more than 100 mathematicians, finally established a comprehensive
classification of the finite simple groups. Many mathematicians agree that this work is valid. 
The results show that almost every simple group falls into 1 or 18 infinite families[]. 
The first infinite family contains the group \( Z_5 \) along with all the cyclic groups of prime order. 
The second infinite family contains all alternating groups \( A_n \), where \(n \ge 5\). The remaining 16 
families are the groups of Lie type which are considerably more complex. Fascinatingly though, there 
are 26 outlier simple groups known as the sporadic groups which fail to fit into 
any of these infinite families. 

\paragraph{}

The first 5 of these 26 were discovered by mathematician Emile Mathieu 
in 1873 and are appropriately named The Mathieu groups. Individually, the Mathieu groups are 
denoted \( M_{11},M_{12}, M_{22}, M_{23}, M_{24} \) where the subscripts signify that the 
Mathieu group \( M_n \) is a 
permutation group on n elements. The group \( M_{24} \) was originally instantiated by Mathieu as the 
the particular subgroup of \( S_{24} \) generated by the 3 arbitrary permutations:
\begin{align*}
    a &= (1, 2, 3, ..., 23) \\
    b &= (3, 17, 10, 7, 9)(5, 4, 13, 14, 19)(11, 12, 23, 8, 18)(21, 16, 15, 20, 22) \\
    c &= (1, 24)(2, 23)(3, 12)(4, 16)(5, 18)(6, 10)(7, 20) ...  (8, 14)(9, 21)(11, 17)(13, 22)(19, 15)
\end{align*}
This representation is opaque and leaves much to be desired for
a mathematician seeking a more natural construction. R.T Curtis, who presnted \( M_{24} \) as
group actions on an icosatetrahedron, stated that the construction was "clever" but "hardly natural."
Modern constructions of \( M_{24} \) 
are often defined as the automorphism group on one of two related finite structures. The first 
is the Steiner system S(5,8,24), a combinatorial block design shown to be isomorphic to \( M_{24} \)
by Witt and Carmichael.
%Two independent works by Witt and Carmichael showed that the automorphism group on this structure is isomorphic to the permutation group generated by Mathieu. 
The second is the extended Golay error-correcting code and is of primary interest to this review
paper. The extended Golay code is distinct from the Steiner
System in its tangibility and practical applications. 
%This feature makes the Golay code feel tractable and presents a tempting target for reasearchers intersted in constructing \( M_{24} \). 
In the paper "Build a Sporadic Group in Your Basement", the 
authors attempt to leverage this by generating a representation for the automorphism on the 
extended Golay code that is "as simple as possible." In doing so, they necessarily also generate a natural and enlightening 
construction for the Mathieu group \( M_{24} \).

\section*{Proofs and Results}
Building the Sporadic Group \( M_{24} \) will require some 
introductory results and definitions from coding theory. 
For this discussion, we
limit our scope to the algebraic properties of codes and omit properties relevant to
engineering applications. These properties are interesting but they are not
relevant to the construction of \( M_{24} \). We begin with some notation and definitions.

%\subsubsection*{Coding Theory}
\smallbreak
\noindent For simplicity, let \( F \) denote the field of binary numbers. Define addition and 
multiplication on this field by
\begin{figure}[ht]
    \centering
\scalebox{0.9}{
\begin{tabular}{|c|c|c|}
    \hline
    +&0&1\\
    \hline
    0&0&1\\
    \hline
    1&1&0\\
    \hline
\end{tabular}
\quad
\quad
\begin{tabular}{|c|c|c|}
    \hline
    x&0&1\\
    \hline
    0&0&0\\
    \hline
    1&0&1\\
    \hline
\end{tabular}
}
\caption{binary addition and multiplication tables for the field \( F \)}
\end{figure}


\theoremstyle{definition}
\newtheorem{definition}{Definition}
\begin{definition}[Binary Code]
    A \textit{Binary Code} with length \( n \) is a set of vectors  \( C = \{c_1, c_2, ..., c_m\} \)
    where each vector \( c_i \) \( i = 0, 1, ..., m \), is chosen from \( F^n \). 
    The vectors of this set are called \textit{Codewords}.
\end{definition} 


\noindent It follows from this definition that the set
\(S = \{[0,0,0], [1,0,0], [0,1,0], [1,1,0]\)
is a binary code of length \( 3 \). 

\smallbreak \noindent
The vectors \( [0,0,0] \) and  \( [0,1,0] \) are
codewords of \( S \). 
The code \( S \) also happens to be closed under vector addition and scalar multiplication.
In other words, \( S \) comprises a subspace of \( F^3 \). This property motivates our next definition.

\begin{definition}[Linear Binary Code]
    A \textit{Linear Binary Code} with dimension \( k \) is a binary code
    that completely exhausts a subspace of \( F^n \) with dimension \( k \).
\end{definition} 



\noindent Returning to our example, we see that the vectors \( [1,0,0] \) and  \( [0,1,0] \) form a basis
for the code \( S \). In particular, \( S \) contains all the vectors generated by that basis. Thus, we say \( S \) is a linear code with dimension \( 2 \). 
It is customary to stack basis vectors for a code \( C \) as row vectors
in a \textit{generator matrix} \( M \). One possible generator matrix for \( S \) is 
\[
    M = \begin{bmatrix}
        1 & 0 & 0\\
        0 & 1 & 0
    \end{bmatrix}
\] 
\smallbreak
\noindent Next, we address the \textit{minimum distance} for a linear code. 
The \textit{distance} between two codewords \( c_1 \) and \( c_2 \), denoted \( \text{dist}(c_1,c_2) \),
is the number of coordinates in which \( c_1 \) and \( c_2 \) differ. The \textit{weight} of 
a codeword \( c \), \( weight(c) \), is then defined to be dist(\( c, \textbf{0} \))
%, where \( \textbf{0} = [0, 0, ..., 0] \)
\newtheorem*{remark}{remark}
\begin{remark}
\noindent Usually, the minimum distance for a binary code \( C \) 
is the minimum value of the set \( \{\text{dist}(c_1, c_2) \mid c_1,c_2 \in C \} \). 
For this review, we are interested in linear codes which always give
\( \text{dist}(c_1,c_2) = \text{dist}(c_1 + c_2, 0) = \text{dist}(c_3, 0) \) for some \( c_3 \in C \). 
In this case, the minimum distance is just the smallest \( weight \) of any codeword \( c \in C\).
\end{remark}


\begin{definition}[Minimum Distance]
    The \textit{Minimum Distance} of a linear binary code is the 
    minimum value of \( \{ \text{weight}(c) \mid c \in C  \} \).

\end{definition} 

%\noindent Up to this point, we have defined 3 important paramters of linear codes. These include
%the \textit{length}, the \textit{dimension}, and the \textit{minimum distance}. We call a
%linear code with length \( n \), dimension \( k \), and minimum distance \( d \) an \( (n,k,d) \)-code.
\begin{remark}
    A linear code with length \( n \), dimension \( k \), and minimum distance \( d \)
    is called an \( (n,k,d) \)-code.
\end{remark}

\subsection*{The Golay Code}
\smallbreak
The extended Golay Code will be instrumental in our construction of \( M_{24} \).
It is a linear binary \( (24,12,8) \)-code that was introduced by 
Marcel Golay in 1949. It is most easily assembled by the following greedy algorithm:
\smallbreak
\noindent First, write down the numbers \(0, 1, 2, ..., 2^{24}-1 \) and consider
their representations as binary codewords of length 24. 
%We will scan the list one by one and collect the codewords of the extended Golay code. 
Begin by adding \( 0 \) to an empty collection
of Golay codewords. 
%This will be the first extended Golay codeword. 
Now scan the values  \( 1, 2, ..., 2^{n-1} \)
and add any value to the collection with distance at least \( 8 \) from any of the 
previously collected codewords. The resulting collection will be the extended Golay code.
\smallbreak
\noindent
The extended Golay code belongs to a special class of linear codes called \textit{self-dual} codes.
This property gives us a computationally inexpensive method for recognizing Golay codewords.

\begin{definition}[Self-Dual Codes]
    A linear code \( C \) is called \textit{self-dual} if \( C = C^\perp\), 
    where \( C^\perp = \{ x \mid x \cdot c = 0, \forall c \in C \} \). 
    Note that \( c_1 \cdot c_2 \) is an inner product
    defined as the usual dot product modulo \( 2 \).
It follows from this definition that the Golay codewords are precisely the words which
are orthogonal to any given generator matrix for the Golay code.
\end{definition} 

\subsection*{Equivalent Codes and Automorphisms}
\smallbreak
\begin{definition}[Equivalent Linear Codes]
    Two Linear Binary Codes \( C \) and \( D \) of length \( n \) are \textit{equivalent}
    if a coordinate permutation on the codewords of \( C \) produces the codewords in \( D \).  
    More precisely, \( C \) and \( D \) are equivalent if there is a bijective map 
    \( \pi: C \to D \) where \( \pi(c) \) is a coordinate permutation on the codeword \( c \). 
\end{definition} 
\iffalse
\begin{remark}
    A coordinate permutation \( \pi: C \to D \) is a homomorphism which preserves the distance
    operation. In particular, 
\(
    \text{dist}(c_1,c_2) = \text{dist}(\pi(c_1), \pi(c_2))
\) 
\noindent for all \( c_1,c_2 \in C \).
\end{remark} 
\fi
%\noindent
%Recall that a homomorphism is a map \( f: A \to B \) that 
%preverves an operation defined on the algebraic structures A and B. 
%That is, for some property \( \mu \) defined on \( A \) and \( B \), we have \( f(\mu_A(a_1,a_2)) = \mu_B(f(a_1), f(a_2)) \) for all \( a_1,a_2 \in A \).
%Examples include linear maps which preserve linearity and group
%homomorphism which preserve the group operation. 
%We will be interested in homomorphisms on Linear Codes which preserve the distance operation.
\noindent An \textit{Automorphism} is a bijective homomorphism of the form 
\( f: A \to A \). Note that  \( f \) maps \( A \) back onto itself. 

\begin{definition}[Linear Code Automorphisms]
    An \textit{Automorphism} on a code \( C \) is a coordinate permutation
    \( \pi: C \to C \) which maps the codewords of \( C \) back \textit{into} the codewords of \( C \).
    Such a mapping must be bijective.
\end{definition} 

\newtheorem{lemma}{Lemma}
\begin{lemma}
    A permutation that maps a basis for a code \( C \) to another basis is necessarily an automorphism on \( C  \).
\end{lemma} 
\begin{lemma}
    The set of automorphisms on a code \( C \) form a group under composition,
    denoted, Aut(\( C \)).
\end{lemma} 


\subsection*{The extended Golay code revisited}
\smallbreak
We will now explore some properties of the extended Golay code in light of \textit{equivalence} and 
\textit{automorphisms}.
Earlier we mentioned that the extended Golay code is an example of a \( (24,12,8) \)-code. We 
will see in the following theorem that any code with this property is equivalent to the 
extended Golay code.


\newtheorem{theorem}{Theorem}
\begin{theorem}[Pless]
    Let \( C \) be a linear binary \(  (24, 12, d)\)-code. Then the following
    statements are equivalent: \\
    \indent 1. The minimum weight of \( C \) is \( d \). \\
    \indent 2. \( C \) is equivalent to the extended Golay code.
\end{theorem}

\noindent We also state the following theorem which will serve as our
primary tool in constructing a natural representation for \( M_{24} \).

\begin{theorem}[Huffman, Pless]
    The full automorphism group of the extended
    binary Golay code, denoted Aut(\( G \)), is isomorphic to \( M_{24}\).
\end{theorem}

\noindent Theorem 2 has the natural consequence that any subgroup of Aut(\( G \)) will be
isomorphic to a subgroup of \( M_{24} \). This suggests a 
clever strategy for constructing \( M_{24} \). 
If we generate a group by composing two automorphisms of \( G \), 
then we are gauranteed the resulting subgroup will be isomorphic to a subgroup of \( M_{24} \).
Thus we might attempt to build \( M_{24} \) by choosing the 'right' pair of automorphisms on \( G \) in the hopes
that they might exhaust all elements of Aut(\( G \)). 
Such a pair would also generate \(M_{24} \).
\subsection*{Building the Sporadic Group}
\smallbreak
\noindent We now have the necessary vocabulary to disscuss a construction of \( M_{24} \). In fact, we will
build the group outright. \\
\noindent After expanding on the coding theory
we have just presented, the authors of "Build a Sporadic Group in Your Basement"
eventually arrive at the following construction for \( M_{24} \). 
The result is a subgroup of the symmetric group \( S_{24} \) generated by two 
permutations:
\begin{align*}
    \tau &= (1, 2, 3, 4, 5, 15, 19, 11, 10, 9, 12, 7, 13, 14, 23, 24, 17, 18, 22, 6, 21, 8, 20)(16)  \\ 
    \rho &= (1, 2, 3)(4, 5, 6) ... (22, 23, 24) \\
\end{align*}
The software package \textbf{GAP} was used to verify that the group generated by
\( \tau \) and \( \rho \) is simple with 244,823,040 elements. This fact along with 
the following lemma stated in the paper is illuminating.

\begin{lemma}
    The only simple group of order 244, 823, 040 is the Mathieu group \( M_{24} \).
\end{lemma}

\noindent The group constructed by \( \tau \) and \( \rho \) is the Mathieu group \( M_{24} \).
We will now attempt to uncover how the authors arrived at this construction. In doing so, we
will also provide an alternate proof that this is \( M_{24} \) through the avenue of 
Theorem 2. In particular, we show that \( \tau \) and \( \rho \) are both automorphisms on 
the extended Golay code.
To this end we introduce two new models of the extended Golay code.

\subsection*{Quadratic Residue Model (R)}
\smallbreak
\noindent The Quadratic Residue model is almost exactly the model originally proposed by
Marcel Golay. The generator matrix for the code is produced by the set \( \{ 1, 2, 3, 4, 6, 8, 9, 12, 13, 16, 18 \} \),
the set of numbers  \( q \) which allow integers solutions to
the equation \( x^2 \equiv q \) (mod \( 23 \)). 
The first codeword in the generator matrix is the vector with ones in these positions,
an additional one in position \( 24 \), and the remaining positions zero. The next
11 rows are generated by applying the permutation
\[
    \sigma = (1, 2, 3, 4, 5, 15, 19, 11, 10, 9, 12, 7, 13, 14, 23, 24, 17, 18, 22, 6, 21, 8, 20)(16)\\ 
\] 


\noindent to the previously generated row. This yields the generator matrix:
\setcounter{MaxMatrixCols}{25}
\setlength\arraycolsep{0.5pt}

\[
    Q = \begin{bmatrix}
        1&1&1&1&0&1&0&1&1&0&0&1&1&0&0&1&0&1&0&0&0&0&0& & 1 \\
        0&1&1&1&1&0&1&0&1&1&0&0&1&1&0&0&1&0&1&0&0&0&0& & 1 \\
        0&0&1&1&1&1&0&1&0&1&1&0&0&1&1&0&0&1&0&1&0&0&0& & 1 \\
        0&0&0&1&1&1&1&0&1&0&1&1&0&0&1&1&0&0&1&0&1&0&0& & 1 \\
        0&0&0&0&1&1&1&1&0&1&0&1&1&0&0&1&1&0&0&1&0&1&0& & 1 \\
        0&0&0&0&0&1&1&1&1&0&1&0&1&1&0&0&1&1&0&0&1&0&1& & 1 \\
        1&0&0&0&0&0&1&1&1&1&0&1&0&1&1&0&0&1&1&0&0&1&0& & 1 \\
        0&1&0&0&0&0&0&1&1&1&1&0&1&0&1&1&0&0&1&1&0&0&1& & 1 \\
        1&0&1&0&0&0&0&0&1&1&1&1&0&1&0&1&1&0&0&1&1&0&0& & 1 \\
        0&1&0&1&0&0&0&0&0&1&1&1&1&0&1&0&1&1&0&0&1&1&0& & 1 \\
        0&0&1&0&1&0&0&0&0&0&1&1&1&1&0&1&0&1&1&0&0&1&1& & 1 \\
        1&0&0&1&0&1&0&0&0&0&0&1&1&1&1&0&1&0&1&1&0&0&1& & 1\\ 
    \end{bmatrix}
\] 

A moderate amount of python code shows that the permutation \( \sigma \) maps the final
row of \( Q \) to the vector sum of columns 1,2,3,4,5,8, and 11. This is the only
combination of basis codewords in \( Q \) which achieves this. Thus \( \sigma \) maps
the basis codewords of \( Q \) to a new linearly independent basis. By Lemma 1, \( \sigma \) is automorphism
on the extended Golay code.

\subsection*{Block-Substitution Model (B)}
\smallbreak
\noindent We now turn our attention to the Block-Substitution model of the Golay code.
This model was introduced by the authors of "Build a Sporadic Group in Your Basement."
We proceed by substituting the \( 3 x 3  \) matrix blocks

\setlength\arraycolsep{4pt}
\[
    I = \begin{bmatrix}
        1 & 0 & 0\\
        0 & 1 & 0\\
        0 & 0 & 1
    \end{bmatrix},
    \quad
    \overline{I} = \begin{bmatrix}
        0 & 1 & 1\\
        1 & 0 & 1\\
        1 & 1 & 0
    \end{bmatrix}
    \quad
    J = \begin{bmatrix}
        1 & 1 & 1\\
        1 & 1 & 1\\
        1 & 1 & 1
    \end{bmatrix}
    \quad
    0 = \begin{bmatrix}
        0 & 0 & 0\\
        0 & 0 & 0\\
        0 & 0 & 0
    \end{bmatrix}
    \quad
    \text{into the matrix}
    \quad
    G = \begin{bmatrix}
        I & 0 & 0 & 0 & \overline{I} & I & I & J\\
        0 & I & 0 & 0 & J & \overline{I} & I & I\\
        0 & 0 & I & 0 & I & J & \overline{I} & I\\
        0 & 0 & 0 & I & I & I & J & \overline{I}
    \end{bmatrix}
\] 
\iffalse
\noindent to obtain

\setlength\arraycolsep{0.5pt}
\[
    G = \begin{bmatrix}
        1&0&0&0&0&0&0&0&0&0&0&0&0&1&1&1&0&0&1&0&0&1&1&1\\
        0&1&0&0&0&0&0&0&0&0&0&0&1&0&1&0&1&0&0&1&0&1&1&1\\
        0&0&1&0&0&0&0&0&0&0&0&0&1&1&0&0&0&1&0&0&1&1&1&1\\
        0&0&0&1&0&0&0&0&0&0&0&0&1&1&1&0&1&1&1&0&0&1&0&0\\
        0&0&0&0&1&0&0&0&0&0&0&0&1&1&1&1&0&1&0&1&0&0&1&0\\
        0&0&0&0&0&1&0&0&0&0&0&0&1&1&1&1&1&0&0&0&1&0&0&1\\
        0&0&0&0&0&0&1&0&0&0&0&0&1&0&0&1&1&1&0&1&1&1&0&0\\
        0&0&0&0&0&0&0&1&0&0&0&0&0&1&0&1&1&1&1&0&1&0&1&0\\
        0&0&0&0&0&0&0&0&1&0&0&0&0&0&1&1&1&1&1&1&0&0&0&1\\
        0&0&0&0&0&0&0&0&0&1&0&0&1&0&0&1&0&0&1&1&1&0&1&1\\
        0&0&0&0&0&0&0&0&0&0&1&0&0&1&0&0&1&0&1&1&1&1&0&1\\
        0&0&0&0&0&0&0&0&0&0&0&1&0&0&1&0&0&1&1&1&1&1&1&0\\
    \end{bmatrix}
\] 
\fi

\bigbreak
\noindent
The result is our generator matrix G for the Block-Substitution model.
Again, we will seek an automorphism that preserves the basis codewords of our generator matrix
\( G \). The cyclic structure of the blocks \( I \), \(\overline{I} \), and \( J \) suggests the 
permutation
\[
    \rho = (1, 2, 3)(4, 5, 6) ... (22, 23, 24) \\
\] 
Indeed, this permutation completely preserves the row vectors of \( G \). Moreover, it is one
of the two permutation we saw early which the authors use to build \( M_{24} \). 

\subsection*{Taking Stock}
\smallbreak
\noindent
We now have two automorphisms, \( \sigma \) and \( \rho \), which operate on distinct Golay
code models \( R \) and \( B \).
\smallbreak
\noindent
Both of these permutations fell naturally out of their respective Golay code models. 
The hope presented in BSGYB is that
the models \( R \) and \( B \) might be "different" enough that their corresponding automorphisms
would generate the full Golay code automorphism group.
We might be tempted
to compose these permutations directly to this end. However this approach
would be meaningless. \( \sigma \) and \( \rho \) operate on 
distinct codes so they do not preserve any useful structure.

\smallbreak
\noindent 
Instead we will seek an equivalence map from \( B \) to \( R \). The resulting map can 
then be used to express \( \sigma \) as an automorphism on the code  \( B \). More precisely,
for an equivalence map, \( \chi \): \( B \to R \), and an automorphism \( \sigma \)
on \( R \), we are gauranteed that \( \chi^{-1} \sigma \chi \) will be an automorphism
on \( B \). This follows because \( \chi^{-1} \sigma \chi \) is injective and maps codewords of 
\( B \) back into \( B \).
Moreover, Theorem 1 promises that this equivalence map exists for our two 
\( (24,12,8) \)-code models. It is simply our task to find it.


\subsection*{Bridging the gap from B to R}
\smallbreak
\noindent
Finding an equivalence map from \( B \) to \( R \) is a computationally difficult problem.
We're looking for some permutation, \( \chi \), which maps each of the \( 2^{12} \) 
codewords of \( B \) into some codeword of \( R \). 
Fortunately, equivalence maps between Golay codes cannot be unique.
Any single equivalence map \( \kappa: B \to R\) can be combined with a
permutation  \( \beta \in Aut(R) \) so that  \( \beta \kappa \) is also an equivalence map.
Still, we expect valid choices for \( \chi \) to be sparse.
\smallbreak
\noindent
A brute force approach would require searching %through 
the entire space of \( 24! \) permutations.
Each iteration would test whether a candidate permutation takes the rows of the generator matrix \( G \) 
to words generated by \( Q \). %to codewords in \( R \).
Definition 3 makes this easy since the codewords generated by \( Q \) are exactly the words which are orthogonal to \( Q \). %we just check that the images of rows in \( G \) are orthogonal to the matrix \( Q \). 
However, this added convenience
will only be useful once we find a stronger set of constraints to narrow the search space. % strategy for traversing the search space.
\smallbreak
\noindent
We can begin by making a tactical guess. The intersection of our two Golay models, 
\( B \cap R \), contains exactly 4 codewords generated by the basis \( \hat{1} = [1, 1, ..., 1]\) and 
\( \hat{z} = [0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1] \). The 
fact that these codewords are contained in both models suggests that \( \chi \) maps
words in \( B \cap R \) back to themselves. In particular, we will make the guess
that \( \chi \) fixes  \( \hat{z} \). This essentially partitions the nonzero coordinates
and zero coordinates of \( \hat{z} \), given respectively by
\begin{align*}
    C &= \{2, 3, 6, 9, 10, 15, 16, 17, 20, 21, 23, 24\},\\
    D &= \{1, 4, 5, 7, 8, 11, 12, 13, 14, 18, 19, 22\}
\end{align*}

\noindent so that coordinates in \( C \) must be sent to \( C \) and coordinates 
in \( D \) must be sent to \( D \). This drastically reduces the search space from \( 24! \)
to  \( (12!)^2 \) possible permutations to consider. This is an improvement but we can do
better by observing some properties of the automorphism group on the extended Golay code.
\smallbreak
\noindent
The original construction of the Mathieu group \( M_{24} \) is well-known to be a 
\textit{5-transitive} permutation group. This property gaurantees that for 
distict elements \( x_1,x_2,x_3,x_4,x_5 \) and distinct elements \( y_1,y_2,y_3,y_4,y_5 \)
chosen from the set \( \{1,2, ..., 24\} \), there is a permutation in \( M_{24} \) which
takes the ordered tuple \( (x_1,x_2,x_3,x_4,x_5) \) to the ordered tuple 
\( (y_1,y_2,y_3,y_4,y_5) \). Theorem 2 tells us that this property also holds for
coordinate permutations of the
automorphism group of the code \( R \). In particular, we can always find a permutation
\( \alpha \in Aut(R) \) which takes a given ordered tuple of 
coordinates \( (i_1, i_2, i_3, i_4, i_5) \) to the coordinates \( (1, 2, 3, 4, 5) \).

\smallbreak
\noindent
This property allows for another simplifying assumption. 
Earlier we mentioned that an equivalence map \( \kappa: B \to R \) can be combined with
an automorphism \( \beta \in Aut(R) \) to make an equivalence map  \( \beta \kappa \).
We know that \( \kappa \) must exist and  \( \beta \) may be selected to send any 
5 coordinates to the coordinates \( (1,2,3,4,5) \). Thus there is some equivalence map \( \beta \kappa \)
which fixes the first five coordinates. We will guess that  \( \chi \) additionally has
this property. This further refines our partition into the three sets:
\[
    F = \{1, 2, 3, 4, 5\} \quad
    C = \{6, 9, 10, 15, 16, 17, 20, 21, 23, 24\}\quad
    D = \{7, 8, 11, 12, 13, 14, 18, 19, 22\}
\]
% I found the authors explanation to a bit 'sporadic' for lack of a better word. contrived

\noindent
where \( F \) is the fixed coordinates of  \( \chi \) 
and \( C \) and \( D \) are disjoint sets which \( \chi \) maps independently.
This is just the result of moving the coordinates \( 1 - 5 \)
from our original \( C \) and \( D \) to the set of fixed coordinates \( F \).
Note that this is consistent with the hypothesis that \( \chi\) sends \( \hat{z} \) 
to \( \hat{z} \).
\smallbreak \noindent
We would now like a method to systematically deduce the mappings of individual
coordinates in \( C \) and \( D \). We will find that tools from combinatorics will
be helpful. The codewords of minimum weight \( d = 8 \) of any Golay code form a 
\( t \) - \( (v, k, \lambda) \) combinatorial block design with parameters 
\( t = 5, v = 24, k = 8 \) and  \( \lambda = 1 \).
For our purposes, this simply means that for a Golay code model, \( M \), and an
ordered 5-tuple of coordinates, \( (i_1, i_2, i_3, i_4, i_5) \), there is exacly
one minimum-weight codeword in \(  M \)  containing all \( 1 \)s at these positions. 
We will leverage this by only considering codewords in \( B \) and \( R \) with minimum 
weight. It turns out that the subset of minimum weight words always forms a basis
for a Golay code. So any permutation which satisfies the minimum weight codewords 
of \( B \) and \( R \) will satisfy all codewords. 
We can then use specific 5-tuples of coordinates in \( F \)
to anchor words in \( B \) to corresponding words in \( R \) in order to deduce
coordinate mappings in \( C \) and \( D \). 
%information about \( F, C, \) and  \( D \) to anchor 
%words in \(  B\) to corresponding words in \( R \). Doing this will give us better insights
%into the mappings of particular coordinates in \( C \) and \( D \).

\subsection*{Determining C and D}
\noindent
Let \( B^\prime \) and  \( R^\prime \) denote the respective subsets of the 
codewords in  \( B \) and \( R \) having minimum weight, \( d = 8 \).
Note that codewords of \( B^\prime \) must map to codewords of  \( R^\prime \) under
an equivalence map.
We know that there is exactly one codeword in \( B^\prime \) starting with five 
consecutive  \( 1 \)s. If our assumption that \( \chi\) fixes the coordinates of \( F \) 
is true, then this word must map to the unique codeword in \( R^\prime \) starting with five ones.
Searching \( B^\prime \) and  \( R^\prime \) for these words yields the mapping:
\begin{align*}
    \chi : &[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \textbf{1}, 0, 0, 1, 0, 0, 1] \\
    \to &[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \textbf{1}, 0, 0, 1, 0, 0, 0]
\end{align*}
\noindent
We've bolded the nonzero coordinates of \( D \) for illustrative purposes. If our assumptions
up to this point have been correct, then the permutation \( \chi \) must take the set of
nonzero coordinates \( \{18, 21, 24\} \to \{16, 18, 21\} \). Moreover, coordinates in 
\( D \) must be mapped back to coordinates in \( D \). Thus the mapping \( 18 \to 18 \)
is determined. We are uncertain about the exact determination of \( \{21, 24\} \to \{16, 21\} \)
however the authors argue that additional fixed points are to be expected. Thus we make another 
simplifying guess and suppose that \( 21 \) is fixed while  \( 24 \to 16 \).
This new information yields the following updated constraints on our desired
equivalence map \( \chi \)
\[
    F = \{1, 2, 3, 4, 5, 18, 21\} \quad
    C = \{6, 9, 10, 15, 16, 17, 20, 23, 24\}   \quad
    D = \{7, 8, 11, 12, 13, 14, 19, 22\} \quad\chi: 24 \to 16\\
\]

\noindent
We've added two additional fixed coordinates. We could attempt to exploit 
this by matching a new pair of codewords in \( B^\prime \) and \( R^\prime \) 
by a different 5-tuple of coordinates from \( F \), say \( (1, 2, 3, 18, 21) \).
But, this would yield the same mapping we found above.
Instead, we can search for codewords in \( B^\prime \) and \( R^\prime \) containing
ones in exactly 4 coordinates \(\text{f}_1,\text{f}_2, \text{f}_3,\text{f}_4 \in\) \( F \),
all others zero. It can be shown that for 
any choice of \(\text{f}_1,\text{f}_2, \text{f}_3,\text{f}_4 \in F\), \( B^\prime \) and  \( R^\prime \)
each contain \( 4 \) codewords meeting this criteria 
(see proof 1.1 in the mathematical comments section). 
\smallbreak \noindent
Pairing this tactic with contraints on nonzero coordinates in \( C \) and \( D \) 
can reveal correspondences between sets of 3 or even 2 codewords in \( B^\prime \) and 
 \( R^\prime \). %mappings narrow down a potential mapping to two corresponding codewords in \( B^\prime \) and \( R^\prime \). 
The authors take one of may paths following this general strategy. %instantiate this general strategy by 
They begin by searching for codewords with
nonzero coordinates intersecting \( F \) in exactly 4 elements and intersecting
\( C \) in exactly 1. 
This reveals 4 independent mappings of the form
\( \{b_1, b_2\} \to \{r_1, r_2\} \) where \( b_1,b_2 \in B^\prime \) and \( r_1,r_2 \in R^\prime \).
Each of these mappings must send the respective nonzero coordinates in \( C \) back to 
coordinates in \( C \).
Thus, 2 possible mapping are revealed for the nonzero coordinates of \( b_1 \) and \( b_2 \) 
contained in \( C \). The authors couple this iterative process with some, arguably arbitrary,
guess work, and eventually present the following equivalence permutation \( \chi \). We
should observe that this mapping is consistent with our assumptions up to this point.



% along with some strategic guessing 
% It seems likely that 

% we will skip a detailed derivation

% guesswork. we will avoid the scenic route


\section*{Mathematical Comments}
\[F = \{1, 2, 3, 4, 5, 18, 21\} \quad\]
Let \( \text{f} = (\text{f}_1,\text{f}_2, \text{f}_3,\text{f}_4) \) be an ordered tuple 
of distinct coordinates chosen from \( F \).
We will show that \( B^\prime \) and  \( R^\prime \)
each contain \( 4 \) codewords having ones at the coordinates \( \text{f}_1,\text{f}_2, \text{f}_3,\text{f}_4 \) and
zeros at coordinates \( F \setminus \{ \text{f}_1,\text{f}_2, \text{f}_3,\text{f}_4 \} \).
To see this, let \( \text{f} = (\text{f}_1,\text{f}_2, \text{f}_3,\text{f}_4) \) 
be any 4-tuple of coordinates in \( F \).
We would like to know how many words in \( B^\prime \)
are full-weight at \( \text{f} \), where \textit{full-weight} denotes the property of having
all 1s at the coordinates of \( \text{f} \).
\smallbreak \noindent
Codewords of \( B^\prime \) have weight \( d = 8 \ge 5 \). Thus a codeword \( c \) in \( B^\prime \) 
is full-weight at \( \text{f} = (\text{f}_1,\text{f}_2, \text{f}_3,\text{f}_4) \) if and only if \( c \) is full-weight at a 5-tuple of 
coordinates containing  \( \text{f} \).
We have 24 total coordinates so there are \( 24 - 4 = 20 \) different
coordinate 5-tuples containing \( \text{f} \). We are guaranteed that for each 5-tuple in this set, \( B^\prime \) contains
a single codeword that is full-weight at that tuple. Thus we have at most \( 20 \) codewords
in \( B^\prime \) which are full-weight at  \( \text{f} \). The exact number is much smaller, 
though, becuase many of these 5-tuples overlap on the same codeword. 
In fact, any single codeword containing \( \text{f} \) must contain \( 8 - 4 = 4 \)
overlapping 5-tuples. So there are \( \frac{20}{4} = 5 \) codewords in \( B^\prime \) 
which are full-weight at \( \text{f} \). 
Insisting that the coordinates of \( F \)

\subsection*{Build a Sporadic Group in your Kaggle Notebook}

%\item First item
%\item Second item
%\end{itemize}


\section*{Discussion}

We have 24 coordinates so any particular 4-tuple is contained in \( 24 - 4 = 20 \) 
different 5-tuples.
uniquely determines a codeword 
we know it shows up in at least 20 codewords, 
\smallbreak
however many of these 5-tuples may overlap
on the same codeword. Any single codeword containing this 4-tuple must contain (8 - 4 = 4)
of these 5-tuples. In other words, any codeword having all 1s at \(i_1,i_2,i_3,and i_4\)
will correspond to correspond to 4 of these 5-tuples. Thus B and R will contain \(\frac{20}{4}=5\)
codewords with all 1's at any given 4 tuple. If we also specify that no 5-tuple contained in
\( F \) is all 1s then we have \( 5-1=4 \) possible words.


The Discussion should be succinct and must not contain subheadings.

\section*{Methods}

Topical subheadings are allowed. Authors must ensure that their Methods section includes adequate experimental and characterization data necessary for others in the field to reproduce their work.

\bibliography{sample}

\noindent LaTeX formats citations and references automatically using the bibliography records in your .bib file, which you can edit via the project menu. Use the cite command for an inline citation, e.g.  \cite{Hao:gidmaps:2014}.

For data citations of datasets uploaded to e.g. \emph{figshare}, please use the \verb|howpublished| option in the bib entry to specify the platform and the link, as in the \verb|Hao:gidmaps:2014| example in the sample bibliography file.

\section*{Acknowledgements (not compulsory)}

Acknowledgements should be brief, and should not include thanks to anonymous referees and editors, or effusive comments. Grant or contribution numbers may be acknowledged.

\section*{Author contributions statement}

Must include all authors, identified by initials, for example:
A.A. conceived the experiment(s),  A.A. and B.A. conducted the experiment(s), C.A. and D.A. analysed the results.  All authors reviewed the manuscript. 

\section*{Additional information}

To include, in this order: \textbf{Accession codes} (where applicable); \textbf{Competing interests} (mandatory statement). 

The corresponding author is responsible for submitting a \href{http://www.nature.com/srep/policies/index.html#competing}{competing interests statement} on behalf of all authors of the paper. This statement must be included in the submitted article file.

\begin{figure}[ht]
\centering
\includegraphics[width=\linewidth]{stream}
\caption{Legend (350 words max). Example legend text.}
\label{fig:stream}
\end{figure}

\begin{table}[ht]
\centering
\begin{tabular}{|l|l|l|}
\hline
Condition & n & p \\
\hline
A & 5 & 0.1 \\
\hline
B & 10 & 0.01 \\
\hline
\end{tabular}
\caption{\label{tab:example}Legend (350 words max). Example legend text.}
\end{table}

Figures and tables can be referenced in LaTeX using the ref command, e.g. Figure \ref{fig:stream} and Table \ref{tab:example}.

\end{document}
